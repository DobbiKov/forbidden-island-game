package test;

import Errors.*;
import Model.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.EnumSource;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

class BoardGameActionsTest {

    private BoardGame boardGame;
    private Player player1, player2, player3, player4;
    private Zone startZone1, startZone2, startZone3, startZone4;
    private Zone adjacentDry, adjacentFlooded, adjacentInaccessible;
    private Zone diagonalDry, diagonalFlooded, diagonalInaccessible;
    private Zone farawayDry;
    private Zone artefactZoneEarth1, artefactZoneEarth2;


    @BeforeEach
    void setUp() {
        Player.resetPlayerCount(); // Reset for each test
        boardGame = new BoardGame();

        // Manually set up players and zones for predictable testing
        // We need specific zones with specific states and locations
        // Let's replace the board generated by the factory
        Zone[][] board = new Zone[5][5];
        BoardGameTestHelper.setPrivateFieldValue(boardGame, "board", board);
        BoardGameTestHelper.setPrivateFieldValue(boardGame, "size", 5);

        // Create specific zones
        startZone1 = new Model.PlayerStartZone(0, 0, ZoneCard.bronze_gate);
        startZone2 = new Model.PlayerStartZone(0, 4, ZoneCard.silver_gate);
        startZone3 = new Model.PlayerStartZone(4, 0, ZoneCard.gold_gate);
        startZone4 = new Model.PlayerStartZone(4, 4, ZoneCard.copper_gate);
        Zone helicopterZone = new Model.HelicopterZone(2, 2); // Center is usually heli zone in tests, but 2,2 is inaccessible by default in this code
        // Let's put the heli zone somewhere else and make 2,2 accessible
        BoardGameTestHelper.setZone(boardGame, 2, 2, new Zone(2,2,true, ZoneCard.dunes_of_deception)); // Make center accessible random zone
        BoardGameTestHelper.setZone(boardGame, 0, 2, helicopterZone); // Put heli zone at 0,2

        adjacentDry = new Zone(0, 1, true, ZoneCard.cliffs_of_abandon);
        adjacentFlooded = new Zone(1, 0, true, ZoneCard.twilight_hollow);
        adjacentFlooded.floodZone();
        adjacentInaccessible = new Zone(1, 1, true, ZoneCard.phantom_rock);
        adjacentInaccessible.floodZone();
        adjacentInaccessible.floodZone();

        diagonalDry = new Zone(1, 1, true, ZoneCard.watchtower); // This is the same as adjacentInaccessible in coord, let's adjust
        // Use different coords to avoid confusion
        diagonalDry = new Zone(1, 1, true, ZoneCard.watchtower); // 1,1 is diagonal from 0,0

        diagonalFlooded = new Zone(1, 3, true, ZoneCard.crimson_forest); // 1,3 is diagonal from 0,4 (startZone2)
        diagonalFlooded.floodZone();
        diagonalInaccessible = new Zone(3, 1, true, ZoneCard.iron_gate); // 3,1 is diagonal from 4,0 (startZone3)
        diagonalInaccessible.makeInaccessible();

        farawayDry = new Zone(3, 3, true, ZoneCard.observatory);

        artefactZoneEarth1 = new Model.ArtefactZone(1, 2, ZoneCard.temple_of_the_moon, Model.Artefact.Earth);
        artefactZoneEarth2 = new Model.ArtefactZone(2, 1, ZoneCard.temle_of_the_sun, Model.Artefact.Earth); // Note the typo in original code: temle_of_the_sun

        // Place zones on the board
        board[0][0] = startZone1; board[0][4] = startZone2; board[4][0] = startZone3; board[4][4] = startZone4;
        board[0][1] = adjacentDry; board[1][0] = adjacentFlooded; board[1][1] = diagonalDry;
        board[1][3] = diagonalFlooded; board[3][1] = diagonalInaccessible;
        board[3][3] = farawayDry; board[0][2] = helicopterZone;
        board[1][2] = artefactZoneEarth1; board[2][1] = artefactZoneEarth2; // Add artefact zones

        // Fill in remaining zones with simple dry zones
        for(int i=0; i<5; i++){
            for(int j=0; j<5; j++){
                if(board[i][j] == null) {
                    board[i][j] = new Zone(i,j,true, Model.ZoneCard.dunes_of_deception); // Use a common card, ensures accessibility
                    // To avoid ZoneCard usage collision with ZoneFactory, maybe use a different strategy or mock ZoneFactory.
                    // For simplicity in tests, assume unique cards were generated for our specific zones, and others are just placeholders.
                }
            }
        }


        // Add players
        player1 = new Player("P1", PlayerRole.Pilot); // Pilot
        player2 = new Player("P2", PlayerRole.Engineer); // Engineer
        player3 = new Player("P3", PlayerRole.Diver); // Diver
        player4 = new Player("P4", PlayerRole.Messenger); // Messenger (or Explorer)
        // Let's make P4 Explorer and add another Player for Messenger tests if needed later
        player4 = new Player("P4", PlayerRole.Explorer);
        Player player5 = new Player("P5", PlayerRole.Messenger);


        BoardGameTestHelper.setPlayers(boardGame, player1, player2, player3, player4, player5); // Using helper
        BoardGameTestHelper.setPlayerCount(boardGame, 5); // Update count as we manually set players
        // The BoardGame code only supports 4 players. Let's stick to 4 for realism.
        BoardGameTestHelper.setPlayers(boardGame, player1, player2, player3, player4); // Using helper
        BoardGameTestHelper.setPlayerCount(boardGame, 4);

        // Assign players to start zones (the addPlayer method does this, but we set players manually)
        player1.setPlayerToZone(startZone1); // Pilot at 0,0
        player2.setPlayerToZone(startZone2); // Engineer at 0,4
        player3.setPlayerToZone(startZone3); // Diver at 4,0
        player4.setPlayerToZone(startZone4); // Explorer at 4,4

        // Start the game state manually for action tests
        BoardGameTestHelper.setGameState(boardGame, GameState.Playing);
        BoardGameTestHelper.setPlayerTurnId(boardGame, 0); // P1's turn (Pilot)
        BoardGameTestHelper.setCurrentPlayerActionsNum(boardGame, 3);
        BoardGameTestHelper.setTreasureDrawnThisTurn(boardGame, false); // Reset flag

        // Clear playersOnInaccessibleZones if they somehow got populated
        BoardGameTestHelper.setPlayersOnInaccessibleZones(boardGame, new ArrayList<>());
        BoardGameTestHelper.setCurrentPlayerRunningFromInaccessibleZone(boardGame, null);

        // Clear claimed artefacts
        BoardGameTestHelper.setClaimedArtefacts(boardGame, java.util.EnumSet.noneOf(Model.Artefact.class));

        // Ensure decks are not empty if cards are needed for tests
        BoardGameTestHelper.getTreasureDeck(boardGame).getDrawCards().clear();
        BoardGameTestHelper.getFloodDeck(boardGame).getDrawCards().clear();
        // Add some default cards back
        BoardGameTestHelper.getTreasureDeck(boardGame).getDrawCards().addAll(Model.TreasureDeck.initTreasureCards());
        BoardGameTestHelper.getFloodDeck(boardGame).getDrawCards().addAll(Model.FloodDeck.collectAllZoneCards());
        BoardGameTestHelper.getTreasureDeck(boardGame).shuffle();
        BoardGameTestHelper.getFloodDeck(boardGame).shuffle();

        // Add Water Rise cards back as startGame adds them
        BoardGameTestHelper.getTreasureDeck(boardGame).addWaterRiseCards();


    }

    // --- Helper to set current player and actions ---
    private void setCurrentPlayer(Player player, int actions) {
        for (int i = 0; i < BoardGameTestHelper.getPlayers(boardGame).length; i++) {
            if (BoardGameTestHelper.getPlayers(boardGame)[i] == player) {
                BoardGameTestHelper.setPlayerTurnId(boardGame, i);
                BoardGameTestHelper.setCurrentPlayerActionsNum(boardGame, actions);
                return;
            }
        }
        fail("Player not found in the game");
    }

    // --- Helper to put players on a zone ---
    private void putPlayersOnZone(Zone zone, Player... players) {
        zone.getPlayers_on_zone().clear(); // Clear existing players
        for(Player p : players) {
            if (p.getPlayer_zone() != null) {
                if(p.getPlayer_zone().getPlayers_on_zone().contains(p)) p.getPlayer_zone().removePlayerFromZone(p);
            }
            p.move_Player(zone); // Use player method which updates both sides
            zone.addPlayerToZone(p);
        }
    }

    // --- Player Action: Move (Standard/Explorer/Diver) ---

    @Test
    @DisplayName("Standard Player (Pilot) can move to adjacent dry zone")
    void standardPlayerCanMoveToAdjacentDry() {
        setCurrentPlayer(player1, 3); // Player1 is Pilot at 0,0
        putPlayersOnZone(startZone1, player1); // Ensure P1 is at 0,0

        boardGame.setPlayerChooseZoneToMoveTo();
        assertEquals(GameState.PlayerChooseWhereToMove, BoardGameTestHelper.getGameState(boardGame));

        boardGame.movePlayerToZone(adjacentDry); // 0,1

        assertEquals(adjacentDry, player1.getPlayer_zone());
        assertTrue(adjacentDry.getPlayers_on_zone().contains(player1));
        assertFalse(startZone1.getPlayers_on_zone().contains(player1));
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));
    }

    @Test
    @DisplayName("Standard Player (Pilot) cannot move to adjacent flooded zone")
    void standardPlayerCannotMoveToAdjacentFlooded() {
        setCurrentPlayer(player1, 3); // Pilot at 0,0
        putPlayersOnZone(startZone1, player1);
        adjacentFlooded.floodZone(); // Ensure it's flooded

        boardGame.setPlayerChooseZoneToMoveTo();
        assertEquals(GameState.PlayerChooseWhereToMove, BoardGameTestHelper.getGameState(boardGame));

        assertThrows(InvalidZoneToMove.class, () -> boardGame.movePlayerToZone(adjacentFlooded)); // 1,0

        assertEquals(startZone1, player1.getPlayer_zone()); // Should not have moved
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(GameState.PlayerChooseWhereToMove, BoardGameTestHelper.getGameState(boardGame)); // State remains choosing
    }

    @Test
    @DisplayName("Standard Player (Pilot) cannot move to adjacent inaccessible zone")
    void standardPlayerCannotMoveToAdjacentInaccessible() {
        setCurrentPlayer(player1, 3); // Pilot at 0,0
        putPlayersOnZone(startZone1, player1);
        adjacentInaccessible.makeInaccessible(); // Ensure it's inaccessible

        boardGame.setPlayerChooseZoneToMoveTo();
        assertEquals(GameState.PlayerChooseWhereToMove, BoardGameTestHelper.getGameState(boardGame));

        assertThrows(InvalidZoneToMove.class, () -> boardGame.movePlayerToZone(adjacentInaccessible)); // 1,1 (original setup has 1,1 as diagonalDry, adjust setUp if needed)
        // Let's ensure adjacentInaccessible is actually adjacent and inaccessible
        boardGame.getBoard()[1][0] = adjacentInaccessible; // Put inaccessible adjacent to 0,0
        adjacentInaccessible.makeInaccessible();


        assertThrows(InvalidZoneToMove.class, () -> boardGame.movePlayerToZone(adjacentInaccessible)); // 1,0

        assertEquals(startZone1, player1.getPlayer_zone()); // Should not have moved
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(GameState.PlayerChooseWhereToMove, BoardGameTestHelper.getGameState(boardGame)); // State remains choosing
    }


    @Test
    @DisplayName("Explorer Player can move to diagonal dry zone")
    void explorerCanMoveToDiagonalDry() {
        setCurrentPlayer(player4, 3); // Player4 is Explorer at 4,4
        putPlayersOnZone(startZone4, player4); // Ensure P4 is at 4,4
        Zone diagDryFrom4_4 = boardGame.getZone(3,3); // farawayDry at 3,3 is diagonal from 4,4

        boardGame.setPlayerChooseZoneToMoveTo();
        assertEquals(GameState.PlayerChooseWhereToMove, BoardGameTestHelper.getGameState(boardGame));
        assertTrue(boardGame.getZonesPossibleForChoosing().contains(diagDryFrom4_4)); // Check it's a valid choice

        boardGame.movePlayerToZone(diagDryFrom4_4); // 3,3

        assertEquals(diagDryFrom4_4, player4.getPlayer_zone());
        assertTrue(diagDryFrom4_4.getPlayers_on_zone().contains(player4));
        assertFalse(startZone4.getPlayers_on_zone().contains(player4));
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));
    }

    @Test
    @DisplayName("Diver Player can move through adjacent flooded zone to reach dry zone")
    void diverCanMoveThroughFlooded() {
        setCurrentPlayer(player3, 3); // Player3 is Diver at 4,0
        putPlayersOnZone(startZone3, player3); // Ensure P3 is at 4,0

        // Setup a path: 4,0 (Dry) -> 4,1 (Flooded) -> 4,2 (Dry)
        Zone floodedZone = boardGame.getZone(4,1); floodedZone.floodZone(); // Ensure 4,1 is flooded and accessible
        Zone targetZone = boardGame.getZone(4,2);

        boardGame.setPlayerChooseZoneToMoveTo();
        assertEquals(GameState.PlayerChooseWhereToMove, BoardGameTestHelper.getGameState(boardGame));

        // Diver should be able to move directly to 4,2 in one action through 4,1
        assertTrue(boardGame.getZonesPossibleForChoosing().contains(targetZone));

        boardGame.movePlayerToZone(targetZone); // 4,2

        assertEquals(targetZone, player3.getPlayer_zone());
        assertTrue(targetZone.getPlayers_on_zone().contains(player3));
        assertFalse(startZone3.getPlayers_on_zone().contains(player3));
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));
    }

    @Test
    @DisplayName("Move action requires actions remaining")
    void moveRequiresActions() {
        setCurrentPlayer(player1, 0); // Pilot with 0 actions
        putPlayersOnZone(startZone1, player1);

        // Attempt to set move state
        assertThrows(NoActionsLeft.class, () -> boardGame.setPlayerChooseZoneToMoveTo()); // Needs action points check first
        // The action point check is inside the setPlayerChoose method in the controller handler wrapper.
        // Let's test the model logic directly here
        BoardGameTestHelper.setCurrentPlayerActionsNum(boardGame, 0);
        assertThrows(NoActionsLeft.class, () -> {
            boardGame.setPlayerChooseZoneToMoveTo(); // State change needs action
            // If the state change happened, the next call would be movePlayerToZone
            // boardGame.movePlayerToZone(adjacentDry); // This would also throw NoActionsLeft if state was set
        });
        // The controller handler catches the error before the state is set.
        // Testing the controller wrapper is where this scenario should be fully verified.
        // Model test confirms the action cost logic itself.
    }

    @Test
    @DisplayName("Move action throws if not in PlayerChooseWhereToMove state")
    void moveThrowsIfNotChoosingMove() {
        setCurrentPlayer(player1, 3);
        putPlayersOnZone(startZone1, player1);
        BoardGameTestHelper.setGameState(boardGame, GameState.Playing); // Ensure wrong state

        assertThrows(InvalidMoveForCurrentGameState.class, () -> boardGame.movePlayerToZone(adjacentDry));
        assertEquals(startZone1, player1.getPlayer_zone()); // Should not have moved
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State unchanged
    }

    @Test
    @DisplayName("Move action throws if choosing invalid zone")
    void moveThrowsIfInvalidZone() {
        setCurrentPlayer(player1, 3);
        putPlayersOnZone(startZone1, player1);
        Zone invalidZone = farawayDry; // Not adjacent

        boardGame.setPlayerChooseZoneToMoveTo();
        assertEquals(GameState.PlayerChooseWhereToMove, BoardGameTestHelper.getGameState(boardGame));

        assertThrows(InvalidZoneToMove.class, () -> boardGame.movePlayerToZone(invalidZone));

        assertEquals(startZone1, player1.getPlayer_zone()); // Should not have moved
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(GameState.PlayerChooseWhereToMove, BoardGameTestHelper.getGameState(boardGame)); // State remains choosing
    }


    // --- Player Action: Shore Up (Standard/Engineer/Explorer) ---

    @Test
    @DisplayName("Standard Player (Pilot) can shore up adjacent flooded zone")
    void standardPlayerCanShoreUpAdjacentFlooded() {
        setCurrentPlayer(player1, 3); // Pilot at 0,0
        putPlayersOnZone(startZone1, player1);
        if(adjacentFlooded.isDry()) adjacentFlooded.floodZone(); // Ensure 1,0 is flooded

        boardGame.setPlayerChooseZoneToShoreUp();
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame));

        boardGame.playerShoreUpZone(adjacentFlooded); // 1,0

        assertEquals(ZoneState.Normal, adjacentFlooded.getZone_state());
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));
    }

    @Test
    @DisplayName("Standard Player (Pilot) can shore up their own flooded zone")
    void standardPlayerCanShoreUpOwnFlooded() {
        setCurrentPlayer(player1, 3); // Pilot
        putPlayersOnZone(adjacentFlooded, player1); // Put player on flooded zone
        if(adjacentFlooded.isDry()) adjacentFlooded.floodZone(); // Ensure it's flooded (it might already be)

        boardGame.setPlayerChooseZoneToShoreUp();
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame));

        boardGame.playerShoreUpZone(adjacentFlooded);

        assertEquals(ZoneState.Normal, adjacentFlooded.getZone_state());
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));
    }

    @Test
    @DisplayName("Engineer Player can shore up adjacent flooded zone using 1 action for first shore up")
    void engineerCanShoreUpAdjacentFloodedFirst() {
        setCurrentPlayer(player2, 3); // Player2 is Engineer at 0,4
        putPlayersOnZone(startZone2, player2);
        Zone adjFlooded = boardGame.getZone(0, 3);
        adjFlooded.floodZone();

        boardGame.setPlayerChooseZoneToShoreUp();
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame));

        boardGame.playerShoreUpZone(adjFlooded);

        assertEquals(ZoneState.Normal, adjFlooded.getZone_state());
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // 1 action used
        assertEquals(1, BoardGameTestHelper.getShoreUpsLeft(boardGame)); // 1 free shore up remaining for this action
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State goes back to Playing after first shore up
    }

    @Test
    @DisplayName("Engineer Player can shore up second zone using the same action")
    void engineerCanShoreUpSecondZone() {
        setCurrentPlayer(player2, 3); // Player2 is Engineer at 0,4
        putPlayersOnZone(startZone2, player2);

        // Setup two adjacent flooded zones
        Zone flooded1 = boardGame.getZone(1, 4);
        Zone flooded2 = boardGame.getZone(0,3); // 0,3 (adjacent to 0,4)
        flooded1.floodZone(); flooded2.floodZone(); startZone2.floodZone();


        boardGame.setPlayerChooseZoneToShoreUp(); // State -> ShoreUp
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame));
        assertTrue(boardGame.getZonesPossibleForChoosing().contains(flooded1));
        assertTrue(boardGame.getZonesPossibleForChoosing().contains(flooded2));
        assertTrue(boardGame.getZonesPossibleForChoosing().contains(startZone2)); // Engineer's current zone (0,4) if flooded


        // First shore up (costs 1 action)
        boardGame.playerShoreUpZone(flooded1); // Shore up 1,0

        assertEquals(ZoneState.Normal, flooded1.getZone_state());
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Action used
        assertEquals(1, BoardGameTestHelper.getShoreUpsLeft(boardGame)); // 1 free shore up left
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State goes back to Playing

        // Engineer can immediately choose to shore up again without spending another action
        // The UI/Controller needs to allow this action after the first shore up
        // In the model, the next shoreUp call from the Engineer will check shoreUpsLeft
        boardGame.setPlayerChooseZoneToShoreUp(); // Set state back to choosing, costs 0 actions technically
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame));


        boardGame.playerShoreUpZone(flooded2); // Shore up 0,3

        assertEquals(ZoneState.Normal, flooded2.getZone_state());
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions should NOT have decreased
        assertEquals(0, BoardGameTestHelper.getShoreUpsLeft(boardGame)); // Free shore up used
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State goes back to Playing

        startZone2.shoreUp();
    }

    @Test
    @DisplayName("Engineer Player cannot shore up a third zone on the same action")
    void engineerCannotShoreUpThirdZone() {
        setCurrentPlayer(player2, 3); // Engineer at 0,4
        putPlayersOnZone(startZone2, player2);

        // Setup three adjacent flooded zones
        Zone flooded1 =  startZone2; if(flooded1.isDry()) flooded1.floodZone(); // 1,0
        Zone flooded2 = boardGame.getZone(0,3); if(flooded2.isDry()) flooded2.floodZone(); // 0,3
        Zone flooded3 = boardGame.getZone(1,4); if(flooded3.isDry()) flooded3.floodZone(); // 1,4

        boardGame.setPlayerChooseZoneToShoreUp(); // State -> ShoreUp
        boardGame.playerShoreUpZone(flooded1); // 1st shore up (action 1)
        boardGame.setPlayerChooseZoneToShoreUp(); // State -> ShoreUp
        boardGame.playerShoreUpZone(flooded2); // 2nd shore up (free part of action 1)
        boardGame.setPlayerChooseZoneToShoreUp(); // State -> ShoreUp

        // The check for NoActionsLeft is in useOneAction, which playerShoreUpZone calls when shoreUpsLeft is 0.

        assertEquals(ZoneState.Flooded, flooded3.getZone_state()); // Zone should not be shored up
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions remain 2
        assertEquals(0, BoardGameTestHelper.getShoreUpsLeft(boardGame)); // Free shore up is 0
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame)); // State remains choosing
    }

    @Test
    @DisplayName("Explorer Player can shore up diagonally adjacent flooded zone")
    void explorerCanShoreUpDiagonalFlooded() {
        setCurrentPlayer(player4, 3); // Player4 is Explorer at 4,4
        putPlayersOnZone(startZone4, player4); // Ensure P4 is at 4,4
        Zone diagFloodedFrom4_4 = boardGame.getZone(3,3); // farawayDry at 3,3 is diagonal from 4,4 - use a different zone
        // Use the diagonalFlooded zone we set up at 1,3, which is diagonal to startZone2 (0,4)

        putPlayersOnZone(startZone2, player4); // Move Explorer to 0,4 for this test
        setCurrentPlayer(player4, 3); // Update current player state
        if(diagonalFlooded.isDry()) diagonalFlooded.floodZone(); // Ensure 1,3 is flooded


        boardGame.setPlayerChooseZoneToShoreUp();
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame));
        assertTrue(boardGame.getZonesToForPlayerShoreUp(player4).contains(diagonalFlooded)); // Check it's a valid choice

        boardGame.playerShoreUpZone(diagonalFlooded); // 1,3

        assertEquals(ZoneState.Normal, diagonalFlooded.getZone_state());
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));
    }


    @Test
    @DisplayName("Shore Up action requires actions remaining (for non-Engineer second shore up)")
    void shoreUpRequiresActions() {
        setCurrentPlayer(player1, 0); // Pilot with 0 actions
        putPlayersOnZone(startZone1, player1);
        adjacentFlooded.floodZone();

        // Attempt to set shore up state
        assertThrows(NoActionsLeft.class, () -> boardGame.setPlayerChooseZoneToShoreUp());
        // As with move, the handler wrapper catches it first. Test model logic directly:
        BoardGameTestHelper.setCurrentPlayerActionsNum(boardGame, 0);
        assertThrows(NoActionsLeft.class, () -> boardGame.setPlayerChooseZoneToShoreUp());
    }

    @Test
    @DisplayName("Shore Up action throws if not in PlayerChooseWhereToShoreUp state")
    void shoreUpThrowsIfNotChoosingShoreUp() {
        setCurrentPlayer(player1, 3);
        putPlayersOnZone(startZone1, player1);
        BoardGameTestHelper.setGameState(boardGame, GameState.Playing); // Ensure wrong state

        assertThrows(InvalidMoveForCurrentGameState.class, () -> boardGame.playerShoreUpZone(adjacentFlooded));
        assertEquals(ZoneState.Flooded, adjacentFlooded.getZone_state()); // State unchanged
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State unchanged
    }

    @Test
    @DisplayName("Shore Up action throws if choosing invalid zone (not flooded or inaccessible)")
    void shoreUpThrowsIfInvalidZone() {
        setCurrentPlayer(player1, 3);
        putPlayersOnZone(startZone1, player1);
        Zone dryZone = adjacentDry; // Not flooded
        Zone inaccessibleZone = adjacentInaccessible; inaccessibleZone.makeInaccessible(); // Inaccessible

        boardGame.setPlayerChooseZoneToShoreUp();
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame));

        assertThrows(InvalidZoneToMove.class, () -> boardGame.playerShoreUpZone(dryZone)); // Cannot shore up dry zone
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame)); // State remains choosing

        // Clicking an inaccessible zone shouldn't be possible based on getZonesToForPlayerShoreUp,
        // but let's test the exception handling anyway by forcing the call if possible.
        // The model's shoreUp method itself throws ZoneIsInaccessibleException
        assertThrows(InvalidZoneToMove.class, () -> boardGame.playerShoreUpZone(inaccessibleZone));
        assertEquals(ZoneState.Inaccessible, inaccessibleZone.getZone_state()); // State unchanged
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(GameState.PlayerChooseWhereToShoreUp, BoardGameTestHelper.getGameState(boardGame)); // State remains choosing

    }


    // --- Player Action: Pilot Fly ---

    @Test
    @DisplayName("Pilot Player can fly to any accessible zone")
    void pilotCanFlyToAnyAccessibleZone() {
        setCurrentPlayer(player1, 3); // Player1 is Pilot at 0,0
        putPlayersOnZone(startZone1, player1);

        Zone targetZone1 = farawayDry; // Anywhere
        Zone targetZone2 = adjacentFlooded; // Anywhere accessible, even if flooded
        if(targetZone2.isDry()) {
            targetZone2.floodZone(); // Ensure it's flooded
        }

        boardGame.setPilotChooseWhereToFlyTo();
        assertEquals(GameState.PilotChooseWhereToFly, BoardGameTestHelper.getGameState(boardGame));

        assertTrue(boardGame.getZonesPossibleForChoosing().contains(targetZone1));
        assertTrue(boardGame.getZonesPossibleForChoosing().contains(targetZone2));
        assertFalse(boardGame.getZonesPossibleForChoosing().contains(startZone1)); // Cannot fly to current zone
        assertFalse(boardGame.getZonesPossibleForChoosing().contains(adjacentInaccessible)); // Cannot fly to inaccessible

        boardGame.flyPilotToZone(targetZone1); // Fly to 3,3

        assertEquals(targetZone1, player1.getPlayer_zone());
        assertTrue(targetZone1.getPlayers_on_zone().contains(player1));
        assertFalse(startZone1.getPlayers_on_zone().contains(player1));
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Uses 1 action
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));

        // Fly again (if allowed by actions remaining)
        boardGame.setPilotChooseWhereToFlyTo();
        boardGame.flyPilotToZone(targetZone2); // Fly to 1,0

        assertEquals(targetZone2, player1.getPlayer_zone());
        assertTrue(targetZone2.getPlayers_on_zone().contains(player1));
        assertFalse(targetZone1.getPlayers_on_zone().contains(player1));
        assertEquals(1, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Uses 1 more action
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));

    }

    @Test
    @DisplayName("Pilot Fly action requires actions remaining")
    void pilotFlyRequiresActions() {
        setCurrentPlayer(player1, 0); // Pilot with 0 actions
        putPlayersOnZone(startZone1, player1);

        // Attempt to set fly state
        assertThrows(NoActionsLeft.class, () -> boardGame.setPilotChooseWhereToFlyTo());
        // Test model directly:
        BoardGameTestHelper.setCurrentPlayerActionsNum(boardGame, 0);
        assertThrows(NoActionsLeft.class, () -> boardGame.setPilotChooseWhereToFlyTo());
    }

    @Test
    @DisplayName("Pilot Fly action throws if not in PilotChooseWhereToFly state")
    void pilotFlyThrowsIfNotChoosingFly() {
        setCurrentPlayer(player1, 3);
        putPlayersOnZone(startZone1, player1);
        BoardGameTestHelper.setGameState(boardGame, GameState.Playing); // Ensure wrong state

        assertThrows(InvalidMoveForCurrentGameState.class, () -> boardGame.flyPilotToZone(farawayDry));
        assertEquals(startZone1, player1.getPlayer_zone()); // Should not have moved
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State unchanged
    }

    @Test
    @DisplayName("Pilot Fly action throws if choosing inaccessible zone")
    void pilotFlyThrowsIfInaccessibleZone() {
        setCurrentPlayer(player1, 3);
        putPlayersOnZone(startZone1, player1);
        Zone inaccessibleZone = adjacentInaccessible; inaccessibleZone.makeInaccessible();

        boardGame.setPilotChooseWhereToFlyTo();
        assertEquals(GameState.PilotChooseWhereToFly, BoardGameTestHelper.getGameState(boardGame));
        assertFalse(boardGame.getZonesPossibleForChoosing().contains(inaccessibleZone)); // Should not be offered

        // Attempt to click it anyway (simulating potential UI issue or direct model call)
        // The model checks if the zone is in the list of possible zones
        assertThrows(InvalidZoneToMove.class, () -> boardGame.flyPilotToZone(inaccessibleZone));

        assertEquals(startZone1, player1.getPlayer_zone()); // Should not have moved
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(GameState.PilotChooseWhereToFly, BoardGameTestHelper.getGameState(boardGame)); // State remains choosing
    }


    // --- Player Action: Navigator Move Player ---

    @Test
    @DisplayName("Navigator Player can choose another player to move")
    void navigatorCanChoosePlayerToMove() {
        setCurrentPlayer(player3, 3); // Player3 is Diver at 4,0 - make them Navigator for this test
        Player navigator = new Player("Navigator", PlayerRole.Navigator);

        BoardGameTestHelper.setPlayers(boardGame, player1, player2, player3, navigator); // Using helper
        putPlayersOnZone(boardGame.getZone(0,0), navigator); // Put Navigator somewhere
        setCurrentPlayer(navigator, 3); // Navigator's turn

        putPlayersOnZone(startZone1, player1); // P1 at 0,0
        putPlayersOnZone(startZone2, player2); // P2 at 0,4
        putPlayersOnZone(startZone3, player3); // P3 at 4,0
        putPlayersOnZone(startZone4, navigator); // P4 at 4,4


        boardGame.setNavigatorChoosePlayerToMove();
        assertEquals(GameState.NavigatorChooseAPlayerToMove, BoardGameTestHelper.getGameState(boardGame));

        Set<Player> choosablePlayers = boardGame.getPlayersToChoose();
        assertEquals(3, choosablePlayers.size()); // Should be P1, P2, P4 (Navigator cannot move self, P3 is not in player array)
        assertTrue(choosablePlayers.contains(player1));
        assertTrue(choosablePlayers.contains(player2));
        // Need to update players array for this test specifically to include the 'navigator' player
        Player[] playersArray = BoardGameTestHelper.getPlayers(boardGame);
        Player p1Original = playersArray[0]; Player p2Original = playersArray[1]; Player p3Original = playersArray[2]; Player p4Original = playersArray[3];
        Player naviTest = new Player("Navi", PlayerRole.Navigator); Player nonNaviTest = new Player("NonNavi", PlayerRole.Pilot);
        BoardGameTestHelper.setPlayers(boardGame, naviTest, nonNaviTest); // Use only 2 players for simplicity
        putPlayersOnZone(boardGame.getZone(0,0), naviTest);
        putPlayersOnZone(boardGame.getZone(0,1), nonNaviTest);
        BoardGameTestHelper.setPlayerCount(boardGame, 2);
        setCurrentPlayer(naviTest, 3);


        boardGame.setNavigatorChoosePlayerToMove();
        assertEquals(GameState.NavigatorChooseAPlayerToMove, BoardGameTestHelper.getGameState(boardGame));
        choosablePlayers = boardGame.getPlayersToChoose();
        assertEquals(1, choosablePlayers.size());
        assertTrue(choosablePlayers.contains(nonNaviTest));
        assertFalse(choosablePlayers.contains(naviTest));

        boardGame.choosePlayerByNavigator(nonNaviTest); // Navigator chooses nonNaviTest
        assertEquals(nonNaviTest, BoardGameTestHelper.getChosenPlayerByNavigator(boardGame));
        assertEquals(GameState.NavigatorChooseAZoneToMovePlayerTo, BoardGameTestHelper.getGameState(boardGame)); // State changes

        BoardGameTestHelper.setPlayers(boardGame, player1, player2, player3, player4); // Using helper
    }


    @Test
    @DisplayName("Navigator can move chosen player to adjacent/diagonal dry zone")
    void navigatorCanMoveChosenPlayerToValidZone() {
        // Setup: Navigator (P1) at 0,0, Player (P2) at 0,1. Make P1 Navigator.
        Player navigator = new Player("Navi", PlayerRole.Navigator);
        Player targetPlayer = player2; // Use P2 as the target
        BoardGameTestHelper.setPlayers(boardGame, navigator, targetPlayer);
        BoardGameTestHelper.setPlayerCount(boardGame, 2);
        putPlayersOnZone(startZone1, navigator); // Navigator at 0,0
        putPlayersOnZone(adjacentDry, targetPlayer); // Target at 0,1
        setCurrentPlayer(navigator, 3);

        // Start the Navigator move sequence
        boardGame.setNavigatorChoosePlayerToMove();
        boardGame.choosePlayerByNavigator(targetPlayer); // Navigator chooses P2
        assertEquals(GameState.NavigatorChooseAZoneToMovePlayerTo, BoardGameTestHelper.getGameState(boardGame));

        // Valid zones for P2 (at 0,1): 0,0 (adjacent dry), 0,2 (adjacent dry/heli), 1,0 (adjacent flooded), 1,1 (diagonal dry)
        // Navigator can move to adjacent/diagonal *dry* zones from the TARGET player's location
        Zone targetZone1 = startZone1; // 0,0 (adjacent dry from 0,1)
        Zone targetZone2 = boardGame.getZone(0,2); if(targetZone2.isFlooded()) targetZone2.shoreUp(); // 0,2 (adjacent dry from 0,1)
        Zone targetZone3 = diagonalDry; // 1,1 (diagonal dry from 0,1)
        Zone invalidFlooded = adjacentFlooded; invalidFlooded.floodZone(); // 1,0 (adjacent flooded from 0,1)
        Zone invalidInacc = adjacentInaccessible; invalidInacc.makeInaccessible(); // 1,1 (if it was inaccessible)

        // Check possible zones
        List<Zone> possibleZones = boardGame.getZonesPossibleForChoosing();
        assertTrue(possibleZones.contains(targetZone1));
        assertTrue(possibleZones.contains(targetZone2));
        assertTrue(possibleZones.contains(targetZone3));
        assertFalse(possibleZones.contains(invalidFlooded));
        assertFalse(possibleZones.contains(invalidInacc));

        // Perform the move to targetZone1
        boardGame.movePlayerToZoneByNavigator(targetZone1);

        assertEquals(targetZone1, targetPlayer.getPlayer_zone()); // Target player moved
        assertFalse(adjacentDry.getPlayers_on_zone().contains(targetPlayer)); // Not on old zone
        assertTrue(targetZone1.getPlayers_on_zone().contains(targetPlayer)); // On new zone
        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Navigator used 1 action
        assertNull(BoardGameTestHelper.getChosenPlayerByNavigator(boardGame)); // Chosen player nulled
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State back to Playing

        // Perform another move with the same navigator action if allowed (Navigator can move up to 2 tiles)
        // The code seems to interpret 'move player' as moving 1 step. Let's test moving 1 step costs 1 action.
        // If the intention was 2 steps for 1 action, the logic needs adjustment.
        // Test moving to targetZone2 (0,2) from targetZone1 (0,0) - this should cost another action.
        setCurrentPlayer(navigator, 2); // Navigator has 2 actions left
        boardGame.setNavigatorChoosePlayerToMove(); // Re-enter choose player state
        boardGame.choosePlayerByNavigator(targetPlayer); // Choose P2 again (now at 0,0)
        assertEquals(GameState.NavigatorChooseAZoneToMovePlayerTo, BoardGameTestHelper.getGameState(boardGame));

        Zone targetZone2From0_0 = adjacentDry; // 0,1 (adjacent dry from 0,0)

        boardGame.movePlayerToZoneByNavigator(targetZone2From0_0); // Move P2 to 0,1

        assertEquals(targetZone2From0_0, targetPlayer.getPlayer_zone());
        assertEquals(1, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Action used
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));

    }


    @Test
    @DisplayName("Navigator Move Player action requires actions remaining")
    void navigatorMovePlayerRequiresActions() {
        Player navigator = new Player("Navi", PlayerRole.Navigator);
        Player targetPlayer = player2;
        BoardGameTestHelper.setPlayers(boardGame, navigator, targetPlayer);
        BoardGameTestHelper.setPlayerCount(boardGame, 2);
        putPlayersOnZone(startZone1, navigator);
        putPlayersOnZone(adjacentDry, targetPlayer);

        setCurrentPlayer(navigator, 0); // Navigator with 0 actions

        // Attempt to set choose player state
        assertThrows(NoActionsLeft.class, () -> boardGame.setNavigatorChoosePlayerToMove());

        // Test model directly:
        BoardGameTestHelper.setCurrentPlayerActionsNum(boardGame, 0);
        assertThrows(NoActionsLeft.class, () -> boardGame.setNavigatorChoosePlayerToMove());
    }

    @Test
    @DisplayName("Navigator Choose Player throws if not in NavigatorChooseAPlayerToMove state")
    void navigatorChoosePlayerThrowsIfNotChoosingPlayer() {
        setCurrentPlayer(player3, 3); // Diver, not Navigator
        putPlayersOnZone(startZone1, player1); // P1 at 0,0
        putPlayersOnZone(startZone2, player2); // P2 at 0,4

        BoardGameTestHelper.setGameState(boardGame, GameState.Playing); // Ensure wrong state

        // Attempt to choose a player directly
        assertThrows(InvalidActionForTheCurrentState.class, () -> boardGame.choosePlayerByNavigator(player2));
        assertNull(BoardGameTestHelper.getChosenPlayerByNavigator(boardGame));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));
    }

    @Test
    @DisplayName("Navigator Move to Zone throws if not in NavigatorChooseAZoneToMovePlayerTo state")
    void navigatorMoveToZoneThrowsIfNotChoosingZone() {
        setCurrentPlayer(player3, 3); // Diver, not Navigator
        putPlayersOnZone(startZone1, player1);
        BoardGameTestHelper.setGameState(boardGame, GameState.Playing); // Ensure wrong state

        // Attempt to move a player via navigator method directly
        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.movePlayerToZoneByNavigator(adjacentDry)); // chosenPlayerByNavigator is null
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));

        // Simulate being in the right state, but chosenPlayerByNavigator is null (shouldn't happen in flow)
        BoardGameTestHelper.setGameState(boardGame, GameState.NavigatorChooseAZoneToMovePlayerTo);
        BoardGameTestHelper.setChosenPlayerByNavigator(boardGame, null);
        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.movePlayerToZoneByNavigator(adjacentDry));
        assertEquals(GameState.NavigatorChooseAZoneToMovePlayerTo, BoardGameTestHelper.getGameState(boardGame));
    }


    // --- Player Action: Give Treasure Card ---

    @Test
    @DisplayName("Player on same zone can give Treasure card")
    void playerOnSameZoneCanGiveTreasureCard() {
        setCurrentPlayer(player1, 3); // Pilot at 0,0
        putPlayersOnZone(startZone1, player1, player2); // P1 & P2 on same zone

        // Give P1 a treasure card
        Card treasureCard = new Card(CardType.FIRE_CARD);
        player1.takeCard(treasureCard);
        assertEquals(1, player1.getHand().getSize());
        assertEquals(0, player2.getHand().getSize());

        boardGame.setPlayerGiveTreasureCards();
        assertEquals(GameState.PlayerChoosingCardToGive, BoardGameTestHelper.getGameState(boardGame));
        assertTrue(boardGame.isThisPlayerChoosingCardToGive(player1));
        assertFalse(boardGame.isThisPlayerChoosingCardToGive(player2));


        boardGame.playerChooseCardToGive(player1, treasureCard);
        assertEquals(treasureCard, BoardGameTestHelper.getPrivateFieldValue(boardGame, "cardToGiveByPlayer"));
        assertEquals(GameState.PlayerChoosePlayerToGiveCardTo, BoardGameTestHelper.getGameState(boardGame));

        Set<Player> choosablePlayers = boardGame.getPlayersToChoose();
        assertEquals(1, choosablePlayers.size());
        assertTrue(choosablePlayers.contains(player2)); // P2 is on same tile and hand < 5


        boardGame.choosePlayerToGiveCardTo(player2); // P1 gives card to P2

        assertFalse(player1.getHand().getCards().contains(treasureCard));
        assertEquals(0, player1.getHand().getSize());
        assertTrue(player2.getHand().getCards().contains(treasureCard));
        assertEquals(1, player2.getHand().getSize());

        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Used 1 action
        assertNull(BoardGameTestHelper.getPrivateFieldValue(boardGame, "cardToGiveByPlayer")); // Card nulled
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State back to Playing
    }

    @Test
    @DisplayName("Messenger Player can give Treasure card to player on different zone")
    void messengerCanGiveTreasureCardToDifferentZone() {
        // Setup: P1 is Messenger at 0,0, P2 is at 0,4
        Player messenger = new Player("Messenger", PlayerRole.Messenger);
        Player otherPlayer = player2;
        BoardGameTestHelper.setPlayers(boardGame, messenger, otherPlayer);
        BoardGameTestHelper.setPlayerCount(boardGame, 2);
        putPlayersOnZone(startZone1, messenger); // Messenger at 0,0
        putPlayersOnZone(startZone2, otherPlayer); // Other player at 0,4
        setCurrentPlayer(messenger, 3);

        Card treasureCard = new Card(CardType.EARTH_CARD);
        messenger.takeCard(treasureCard);
        assertEquals(1, messenger.getHand().getSize());
        assertEquals(0, otherPlayer.getHand().getSize());

        boardGame.setPlayerGiveTreasureCards();
        assertEquals(GameState.PlayerChoosingCardToGive, BoardGameTestHelper.getGameState(boardGame));

        boardGame.playerChooseCardToGive(messenger, treasureCard);
        assertEquals(GameState.PlayerChoosePlayerToGiveCardTo, BoardGameTestHelper.getGameState(boardGame));

        Set<Player> choosablePlayers = boardGame.getPlayersToChoose();
        assertEquals(1, choosablePlayers.size());
        assertTrue(choosablePlayers.contains(otherPlayer)); // P2 is choosable even if on different tile

        boardGame.choosePlayerToGiveCardTo(otherPlayer); // Messenger gives card to P2

        assertFalse(messenger.getHand().getCards().contains(treasureCard));
        assertEquals(0, messenger.getHand().getSize());
        assertTrue(otherPlayer.getHand().getCards().contains(treasureCard));
        assertEquals(1, otherPlayer.getHand().getSize());

        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Used 1 action
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State back to Playing
    }

    @Test
    @DisplayName("Give Card action requires actions remaining")
    void giveCardRequiresActions() {
        setCurrentPlayer(player1, 0); // Pilot with 0 actions
        putPlayersOnZone(startZone1, player1, player2);
        player1.takeCard(new Card(CardType.FIRE_CARD));

        // Attempt to set give card state
        assertThrows(NoActionsLeft.class, () -> boardGame.setPlayerGiveTreasureCards());
    }

    @Test
    @DisplayName("Player Choose Card to Give throws if not in PlayerChoosingCardToGive state")
    void chooseCardToGiveThrowsIfNotChoosingCard() {
        setCurrentPlayer(player1, 3);
        putPlayersOnZone(startZone1, player1);
        Card card = new Card(CardType.WATER_CARD);
        player1.takeCard(card);
        BoardGameTestHelper.setGameState(boardGame, GameState.Playing);

        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.playerChooseCardToGive(player1, card));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));
    }

    @Test
    @DisplayName("Player Choose Player to Give Card throws if not in PlayerChoosePlayerToGiveCardTo state")
    void choosePlayerToGiveCardThrowsIfNotChoosingPlayer() {
        setCurrentPlayer(player1, 3);
        putPlayersOnZone(startZone1, player1, player2);
        Card card = new Card(CardType.WATER_CARD);
        player1.takeCard(card);
        BoardGameTestHelper.setGameState(boardGame, GameState.PlayerChoosingCardToGive); // Correct state for choosing card
        boardGame.playerChooseCardToGive(player1, card); // Choose the card, state changes to PlayerChoosePlayerToGiveCardTo

        BoardGameTestHelper.setGameState(boardGame, GameState.Playing); // Force wrong state

        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.choosePlayerToGiveCardTo(player2));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame));
    }

    @Test
    @DisplayName("Player Cannot Give Card to player not on same tile (unless Messenger)")
    void playerCannotGiveCardToPlayerNotOnSameTile() {
        // Setup: P1 at 0,0, P2 at 0,4. P1 is not Messenger.
        setCurrentPlayer(player1, 3); // Pilot at 0,0
        putPlayersOnZone(startZone1, player1); // P1 at 0,0
        putPlayersOnZone(startZone2, player2); // P2 at 0,4

        Card treasureCard = new Card(CardType.FIRE_CARD);
        player1.takeCard(treasureCard);

        boardGame.setPlayerGiveTreasureCards();
        assertEquals(GameState.PlayerChoosingCardToGive, BoardGameTestHelper.getGameState(boardGame));
        boardGame.playerChooseCardToGive(player1, treasureCard);
        assertEquals(GameState.PlayerChoosePlayerToGiveCardTo, BoardGameTestHelper.getGameState(boardGame));

        Set<Player> choosablePlayers = boardGame.getPlayersToChoose();
        assertTrue(choosablePlayers.isEmpty()); // P2 should not be choosable

        // Attempt to give to P2 anyway (simulating UI error)
        assertThrows(InvalidParameterException.class, () -> boardGame.choosePlayerToGiveCardTo(player2)); // Check if choosePlayerToGiveCardTo validates target
        // The model validates if the target is choosable. getPlayersToChooseForGivingCard filters based on location/role/handsize.
        // If you force call choosePlayerToGiveCardTo with an invalid player, the check in the model will likely fail
        // due to the check `!current_player.getPlayer_zone().getPlayers_on_zone().contains(p)`
    }

    @Test
    @DisplayName("Player Cannot Give Card to player with full hand (5+ cards)")
    void playerCannotGiveCardToPlayerWithFullHand() {
        setCurrentPlayer(player1, 3); // Pilot at 0,0
        putPlayersOnZone(startZone1, player1, player2); // P1 & P2 on same zone

        Card treasureCard = new Card(CardType.FIRE_CARD);
        player1.takeCard(treasureCard); // P1 has 1 card

        // Fill P2's hand to 5
        for(int i=0; i<5; i++) {
            player2.takeCard(new Card(CardType.WATER_CARD));
        }
        assertEquals(5, player2.getHand().getSize());
        assertFalse(player2.getHand().isOverflow()); // Not overflowing yet

        boardGame.setPlayerGiveTreasureCards();
        boardGame.playerChooseCardToGive(player1, treasureCard);
        assertEquals(GameState.PlayerChoosePlayerToGiveCardTo, BoardGameTestHelper.getGameState(boardGame));

        Set<Player> choosablePlayers = boardGame.getPlayersToChoose();
        assertTrue(choosablePlayers.isEmpty()); // P2 should not be choosable because hand is >= 5

        // Fill P2's hand to 6 (overflowing)
        player2.takeCard(new Card(CardType.EARTH_CARD));
        assertEquals(6, player2.getHand().getSize());
        assertTrue(player2.getHand().isOverflow());

        boardGame.setPlayerGiveTreasureCards();
        boardGame.playerChooseCardToGive(player1, treasureCard);
        assertEquals(GameState.PlayerChoosePlayerToGiveCardTo, BoardGameTestHelper.getGameState(boardGame));
        choosablePlayers = boardGame.getPlayersToChoose();
        assertTrue(choosablePlayers.isEmpty()); // P2 should not be choosable

        // Test attempting to give to P2 anyway
        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.choosePlayerToGiveCardTo(player2)); // Model checks player hand size
    }


    // --- Player Action: Take Artefact ---

    @Test
    @DisplayName("Player can Take Artefact if on ArtefactZone with 4 matching cards")
    void canTakeArtefactIfOnZoneWithCards() {
        setCurrentPlayer(player1, 3); // Pilot
        putPlayersOnZone(artefactZoneEarth1, player1); // Put P1 on an Earth Artefact Zone

        // Give P1 4 Earth cards
        for(int i=0; i<4; i++) {
            player1.takeCard(new Card(CardType.EARTH_CARD));
        }
        assertEquals(4, player1.getHand().getSize());
        assertTrue(player1.getArtefacts().isEmpty());
        assertTrue(BoardGameTestHelper.getClaimedArtefacts(boardGame).isEmpty());


        boardGame.takeArtefact(); // Action is triggered directly from UI button

        assertEquals(2, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Used 1 action
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State remains Playing
        assertEquals(0, player1.getHand().getSize()); // 4 cards discarded
        assertEquals(4, BoardGameTestHelper.getTreasureDeck(boardGame).getDiscardSize()); // Cards are in discard
        assertEquals(1, player1.getArtefacts().size());
        assertTrue(player1.getArtefacts().contains(Artefact.Earth));
        assertTrue(BoardGameTestHelper.getClaimedArtefacts(boardGame).contains(Artefact.Earth)); // Artefact is claimed
    }


    @Test
    @DisplayName("Take Artefact action requires actions remaining")
    void takeArtefactRequiresActions() {
        setCurrentPlayer(player1, 0); // Pilot with 0 actions
        putPlayersOnZone(artefactZoneEarth1, player1);

        // Give P1 4 Earth cards
        for(int i=0; i<4; i++) {
            player1.takeCard(new Card(CardType.EARTH_CARD));
        }

        assertThrows(NoActionsLeft.class, () -> boardGame.takeArtefact());
        assertEquals(0, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions remain 0
        assertTrue(player1.getArtefacts().isEmpty()); // Artefact not taken
    }

    @Test
    @DisplayName("Take Artefact throws if not on ArtefactZone")
    void takeArtefactThrowsIfNotOnArtefactZone() {
        setCurrentPlayer(player1, 3); // Pilot
        putPlayersOnZone(startZone1, player1); // Put P1 on a non-artefact zone

        // Give P1 4 Earth cards
        for(int i=0; i<4; i++) {
            player1.takeCard(new Card(CardType.EARTH_CARD));
        }

        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.takeArtefact());
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertTrue(player1.getArtefacts().isEmpty()); // Artefact not taken
    }

    @Test
    @DisplayName("Take Artefact throws if not enough matching cards")
    void takeArtefactThrowsIfNotEnoughCards() {
        setCurrentPlayer(player1, 3); // Pilot
        putPlayersOnZone(artefactZoneEarth1, player1); // Put P1 on an Earth Artefact Zone

        // Give P1 only 3 Earth cards
        for(int i=0; i<3; i++) {
            player1.takeCard(new Card(CardType.EARTH_CARD));
        }
        assertEquals(3, player1.getHand().getSize());

        assertThrows(IllegalStateException.class, () -> boardGame.takeArtefact()); // Model throws IllegalStateException
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(3, player1.getHand().getSize()); // Cards not discarded
        assertTrue(player1.getArtefacts().isEmpty()); // Artefact not taken
        assertTrue(BoardGameTestHelper.getClaimedArtefacts(boardGame).isEmpty()); // Artefact not claimed
    }

    @Test
    @DisplayName("Take Artefact throws if artefact is already claimed")
    void takeArtefactThrowsIfAlreadyClaimed() {
        setCurrentPlayer(player1, 3); // Pilot
        putPlayersOnZone(artefactZoneEarth1, player1); // Put P1 on an Earth Artefact Zone

        // Give P1 4 Earth cards
        for(int i=0; i<4; i++) {
            player1.takeCard(new Card(CardType.EARTH_CARD));
        }
        assertEquals(4, player1.getHand().getSize());

        // Manually claim the artefact
        BoardGameTestHelper.getClaimedArtefacts(boardGame).add(Artefact.Earth);
        assertTrue(BoardGameTestHelper.getClaimedArtefacts(boardGame).contains(Artefact.Earth));

        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.takeArtefact());
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Actions not spent
        assertEquals(4, player1.getHand().getSize()); // Cards not discarded
        assertTrue(player1.getArtefacts().isEmpty()); // Artefact not taken
        assertTrue(BoardGameTestHelper.getClaimedArtefacts(boardGame).contains(Artefact.Earth)); // Artefact remains claimed
    }

    // --- Player Action: Discard Card ---

    @Test
    @DisplayName("Player can discard a card when hand is full (overflowing)")
    void canDiscardCardWhenHandOverflowing() {
        setCurrentPlayer(player1, 3); // Pilot
        // Give P1 6 cards (overflowing)
        for(int i=0; i<6; i++) {
            player1.takeCard(new Card(CardType.FIRE_CARD));
        }
        assertEquals(6, player1.getHand().getSize());
        assertTrue(player1.getHand().isOverflow());

        // Simulate endTurn triggering discard state (this state is usually set by endTurn)
        BoardGameTestHelper.setGameState(boardGame, GameState.Discarding);

        Card cardToDiscard = player1.getHand().getCards().get(0);
        assertEquals(0, BoardGameTestHelper.getTreasureDeck(boardGame).getDiscardSize());

        boardGame.setPlayerDiscardCard();
        assertTrue(boardGame.isPlayerChoosingCardToDiscard());
        assertTrue(boardGame.isThisPlayerChoosingCardToDiscard(player1));

        boardGame.playerDiscardCard(player1, cardToDiscard);

        assertEquals(5, player1.getHand().getSize());
        assertFalse(player1.getHand().getCards().contains(cardToDiscard));
        assertEquals(1, BoardGameTestHelper.getTreasureDeck(boardGame).getDiscardSize()); // Card goes to discard
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State remains Discarding if still overflowing
        assertFalse(player1.getHand().isOverflow()); // Now hand is 5, not overflowing, state should change

        // the test where discarding makes hand <= 5
        setUp(); // Reset state
        setCurrentPlayer(player1, 3);
        // Give P1 6 cards
        for(int i=0; i<6; i++) {
            player1.takeCard(new Card(CardType.FIRE_CARD));
        }
        BoardGameTestHelper.setGameState(boardGame, GameState.Discarding);
        cardToDiscard = player1.getHand().getCards().get(0);

        boardGame.setPlayerDiscardCard();
        boardGame.playerDiscardCard(player1, cardToDiscard);

        assertEquals(5, player1.getHand().getSize());
        assertFalse(player1.getHand().isOverflow());
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State changes to Playing
        assertEquals(0, BoardGameTestHelper.getPlayerTurnId(boardGame)); // Still player1's turn after discard (doesn't end turn)

    }

    @Test
    @DisplayName("Player can discard a card even if hand is not full (optional discard)")
    void canDiscardCardWhenHandNotFull() {
        // The UI button for Discard is only visible when hand > 5, but the model method allows it.
        // Test direct model call.
        setCurrentPlayer(player1, 3); // Pilot
        // Give P1 3 cards (not overflowing)
        for(int i=0; i<3; i++) {
            player1.takeCard(new Card(CardType.FIRE_CARD));
        }
        assertEquals(3, player1.getHand().getSize());
        assertFalse(player1.getHand().isOverflow());

        // Simulate entering discard state (UI normally prevents this)
        BoardGameTestHelper.setGameState(boardGame, GameState.PlayerChooseCardToDiscard); // Model method uses this state name
        assertTrue(boardGame.isPlayerChoosingCardToDiscard());

        Card cardToDiscard = player1.getHand().getCards().get(0);
        assertEquals(0, BoardGameTestHelper.getTreasureDeck(boardGame).getDiscardSize());

        boardGame.playerDiscardCard(player1, cardToDiscard);

        assertEquals(2, player1.getHand().getSize());
        assertFalse(player1.getHand().getCards().contains(cardToDiscard));
        assertEquals(1, BoardGameTestHelper.getTreasureDeck(boardGame).getDiscardSize());
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State changes to Playing
        assertEquals(3, BoardGameTestHelper.getCurrentPlayerActionsNum(boardGame)); // Discard doesn't use action
    }


    @Test
    @DisplayName("Discard Card action throws if not in PlayerChooseCardToDiscard state")
    void discardCardThrowsIfNotChoosingDiscard() {
        setCurrentPlayer(player1, 3); // Pilot
        Card card = new Card(CardType.WATER_CARD);
        player1.takeCard(card);
        BoardGameTestHelper.setGameState(boardGame, GameState.Playing); // Ensure wrong state

        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.playerDiscardCard(player1, card));
        assertEquals(GameState.Playing, BoardGameTestHelper.getGameState(boardGame)); // State unchanged
    }

    @Test
    @DisplayName("Discard Card action throws if not current player")
    void discardCardThrowsIfNotCurrentPlayer() {
        setCurrentPlayer(player1, 3); // P1's turn
        player2.takeCard(new Card(CardType.FIRE_CARD)); // P2 has a card
        BoardGameTestHelper.setGameState(boardGame, GameState.PlayerChooseCardToDiscard); // Simulate discard state

        Card cardToDiscard = player2.getHand().getCards().get(0);

        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.playerDiscardCard(player2, cardToDiscard)); // P2 tries to discard
        assertEquals(1, player2.getHand().getSize()); // Card not discarded
        assertEquals(GameState.PlayerChooseCardToDiscard, BoardGameTestHelper.getGameState(boardGame)); // State unchanged
    }

    @Test
    @DisplayName("Discard Card action throws if card not in player's hand")
    void discardCardThrowsIfCardNotInHand() {
        setCurrentPlayer(player1, 3); // P1's turn
        player1.takeCard(new Card(CardType.FIRE_CARD)); // P1 has one card
        Card cardNotInHand = new Card(CardType.WATER_CARD); // P1 doesn't have this

        BoardGameTestHelper.setGameState(boardGame, GameState.PlayerChooseCardToDiscard); // Simulate discard state

        assertThrows(InvalidStateOfTheGameException.class, () -> boardGame.playerDiscardCard(player1, cardNotInHand));
        assertEquals(1, player1.getHand().getSize()); // Card count unchanged
        assertEquals(GameState.PlayerChooseCardToDiscard, BoardGameTestHelper.getGameState(boardGame)); // State unchanged
    }
}
